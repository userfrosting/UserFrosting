<!DOCTYPE html><html>

<head>
<meta charset="utf-8">
<title>tutorial-lesson-2</title>

</head>
<body>
<p>So you&#39;ve completed <a href="%7B%7Bsite.url%7D%7D/tutorials/lesson-1-new-page">Lesson 1</a> and you&#39;re saying to yourself, &quot;ok, but how do I make this page actually <em>do</em> something?&quot; </p>

<p>This tutorial will guide you through setting up a simple form that can be used to update some information in the database.  For simplicity we will use a contrived example - updating the title for every user who belongs to a particular group.  However, the general pattern can be applied to any aspect of your data model.</p>

<h2 id="toc_0">Creating the Form</h2>

<p>To begin, we will create a new page that will contain the form itself.  Creating a page is covered in <a href="%7B%7Bsite.url%7D%7D/tutorials/lesson-1-new-page">Lesson 1</a>, so please go through that tutorial first.  </p>

<p>With all of our routes, you may notice that <code>index.php</code> could easily get to be quite long.  To help break the code into more manageable chunks, we&#39;ll factor out our code into controller classes, with each class in a separate file.  In <code>userfrosting/controllers/GroupController.php</code>, we&#39;ll create a method <code>pageGroupTitles</code>:</p>

<pre><code>public function pageGroupTitles(){
   // Access-controlled resource
   if (!$this-&gt;_app-&gt;user-&gt;checkAccess(&#39;uri_group_titles&#39;)){
       $this-&gt;_app-&gt;notFound();
   }
    
   // Get a list of all groups
   $groups = GroupLoader::fetchAll();
   
   $this-&gt;_app-&gt;render(&#39;group-titles.html&#39;, [
       &#39;page&#39; =&gt; [
           &#39;author&#39; =&gt;         $this-&gt;_app-&gt;site-&gt;author,
           &#39;title&#39; =&gt;          &quot;Update Group Titles&quot;,
           &#39;description&#39; =&gt;    &quot;Update the title for every user in a particular group&quot;,
           &#39;alerts&#39; =&gt;         $this-&gt;_app-&gt;alerts-&gt;getAndClearMessages()
       ],
       &quot;groups&quot; =&gt; $groups     
   ]);   
}</code></pre>

<p>We&#39;ll also create the form template file, <code>group-titles.html</code>:</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
{% include &#39;components/head.html&#39; %} 
&lt;body&gt;
  &lt;div id=&quot;wrapper&quot;&gt;
    {% include &#39;components/nav-account.html&#39; %}
    &lt;div id=&quot;page-wrapper&quot;&gt;
      {% include &#39;components/alerts.html&#39; %}
      &lt;div class=&quot;row&quot;&gt;
        &lt;div class=&quot;col-lg-6&quot;&gt;
          &lt;div class=&quot;panel panel-primary&quot;&gt;
            &lt;div class=&quot;panel-heading&quot;&gt;
              &lt;h3 class=&quot;panel-title&quot;&gt;&lt;i class=&quot;fa fa-users&quot;&gt;&lt;/i&gt; Change Group Titles&lt;/h3&gt;
            &lt;/div&gt;
            &lt;div class=&quot;panel-body&quot;&gt;
              &lt;form class=&quot;form-horizontal&quot; role=&quot;form&quot; name=&quot;titles&quot; action=&quot;{{site.uri.public}}/groups/titles&quot; method=&quot;post&quot;&gt;
                {% include &#39;common/components/csrf.html&#39; %}
                &lt;div class=&quot;form-group&quot;&gt;
                  &lt;label for=&quot;input_group&quot; class=&quot;col-sm-4 control-label&quot;&gt;Primary group&lt;/label&gt;
                  &lt;div class=&quot;col-sm-8&quot;&gt;
                    &lt;select id=&quot;input_group&quot; class=&quot;form-control select2&quot; name=&quot;group_id&quot;&gt;
                      {% for id, group in groups %}
                      &lt;option value=&quot;{{id}}&quot;&gt;{{group.name}}&lt;/option&gt;
                      {% endfor %}
                    &lt;/select&gt;
                  &lt;/div&gt;
                &lt;/div&gt;
                &lt;div class=&quot;form-group&quot;&gt;
                  &lt;label for=&quot;input_title&quot; class=&quot;col-sm-4 control-label&quot;&gt;New Title&lt;/label&gt;
                  &lt;div class=&quot;col-sm-8&quot;&gt;
                    &lt;input type=&quot;text&quot; id=&quot;input_title&quot; class=&quot;form-control&quot; name=&quot;title&quot; placeholder=&quot;Please choose a new title&quot;&gt;
                    &lt;p class=&quot;help-block&quot;&gt;This will become the new title for all users in the selected group.&lt;/p&gt;
                  &lt;/div&gt;
                &lt;/div&gt;
                &lt;div class=&quot;form-group text-center&quot;&gt;
                  &lt;button type=&quot;submit&quot; class=&quot;btn btn-success text-center&quot;&gt;Update Titles&lt;/button&gt;
                &lt;/div&gt;
              &lt;/form&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
      {% include &#39;components/footer.html&#39; %}  
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>

<p>Nothing too fancy here.  We&#39;re creating a form with the name <code>titles</code>, and giving it two fields: a <code>&lt;select&gt;</code> control, for choosing the group name, and a text input, for specifying the new title that will be given to all primary members of the selected group.</p>

<p>You&#39;ll notice that we have the form <code>POST</code> to the <strong>exact same URL</strong> as the URL of the page itself.    How can we do this?  Well, it turns out that an HTTP request consists not just of a <strong>URL</strong>, but an <strong>HTTP method</strong> as well.  Thus, making a <code>GET</code> request from <code>http://example.com/groups/titles</code> is different from making a <code>POST</code> request to <code>http://example.com/groups/titles</code>.</p>

<p>Slim can detect the difference between these two requests, and actually treats them as separate routes!  Thus, we can have:</p>

<pre><code>$app-&gt;get(&#39;/groups/titles/?&#39;, function () use ($app) {    
    // Do what we need to do to render the page containing the form in the GET route
});</code></pre>

<p>and also</p>

<pre><code>$app-&gt;post(&#39;/groups/titles/?&#39;, function () use ($app) {    
    // Process the form submission in the POST route
});</code></pre>

<p>Note the difference between <code>$app-&gt;get(...</code> and <code>$app-&gt;post(...</code>.</p>

<p>That answers the <em>how</em>, but what about the <em>why</em>?  To answer this, we must understand the principles of <a href="https://en.wikipedia.org/wiki/Representational_state_transfer">REST</a>:</p>

<blockquote>
<p>RESTful systems typically, but not always, communicate over the Hypertext Transfer Protocol with the same HTTP verbs (GET, POST, PUT, DELETE, etc.) which web browsers use to retrieve web pages and to send data to remote servers. REST interfaces usually involve collections of resources with identifiers, for example <code>/people/paul</code>, which can be operated upon using standard verbs, such as <code>DELETE /people/paul</code>.</p>
</blockquote>

<p>The keywords here are <strong>resources</strong> and <strong>verbs</strong>.  Semantically, we are to understand URLs as representing abstract resources.  In this case, we might want to think of <code>/groups/titles</code> as a <a href="https://en.wikipedia.org/wiki/Web_resource">resource</a> representing something like &quot;a service for setting a common title for every member of any given group&quot;.  </p>

<p>Thus, <code>GET</code>ting that resource gives us an HTML page containing a form that we can fill out to interact with that service.  <code>POST</code>ing to that resource, on the other hand, actually invokes the service with the parameters specified by the filled-out form.</p>

<p>Ok, enough about REST.  Let&#39;s invoke our controller method <code>pageGroupTitles</code> in our <code>GET</code> route:</p>

<pre><code>$app-&gt;get(&#39;/groups/titles/?&#39;, function () use ($app) {    
  $controller = new UF\GroupController($app);
  return $controller-&gt;pageGroupTitles();
});</code></pre>

<p>And then we should be able to visit <code>groups/titles</code>:</p>

<p><img src="%7B%7Bsite.url%7D%7D/img/tutorials/process-form-1.png" alt="UserFrosting - processing a form submission - 1"></p>

<h2 id="toc_1">Processing the Submitted Form</h2>

<p>Alright, we now have a page that contains a form that will <code>POST</code> to <code>/groups/titles</code>.  Let&#39;s set up our <code>POST</code> route:</p>

<pre><code>$app-&gt;post(&#39;/groups/titles/?&#39;, function () use ($app) {    
  $controller = new UF\GroupController($app);
  return $controller-&gt;updateGroupTitles();
});</code></pre>

<p>Where <code>updateGroupTitles</code> is a method that we will define, again in the <code>GroupController</code> class:</p>

<pre><code>public function updateGroupTitles(){
  ...
}</code></pre>

<h3 id="toc_2">Authorization (Access Control)</h3>

<p>Just like in the <code>GET</code> route, we need to check that the client actually has permission to perform the <code>POST</code> request.  In some situations, we might want a more fine-grained approach to authorization, where access is granted or denied depending on the contents of the fields that are submitted.  For example, in the &quot;update user&quot; resource, users may be allowed to update some user fields but not others.</p>

<p>For simplicity, in this case we wil use a single authorization hook to control access to the entire route.  To make things even simpler, we will use the same authorization hook for <code>POST</code>ing to this resource as we do for <code>GET</code>ting from it:</p>

<pre><code>public function updateGroupTitles(){
   // Access-controlled resource
   if (!$this-&gt;_app-&gt;user-&gt;checkAccess(&#39;uri_group_titles&#39;)){
       $this-&gt;_app-&gt;notFound();
   }
   
   ...
}</code></pre>

<h3 id="toc_3">Validating the Submitted Input</h3>

<p>The next thing we need to do is validate the input.  After all, the cardinal rule of web development is to <strong>never trust user input</strong>!  If we don&#39;t validate the input, we potentially leave ourselves vulnerable to all sorts of security and usability hazards.</p>

<p>First, we retrieve the <code>POST</code>ed data:</p>

<p><code>$post = $this-&gt;_app-&gt;request-&gt;post();</code></p>

<p>Now, <code>$post</code> contains the raw request data, which is basically equivalent to PHP&#39;s <code>$_POST</code> array.  To validate the data, we can either go through and check each field in the code, or we can use <a href="https://github.com/alexweissman/fortress">Fortress</a> to automatically validate the data against a <a href="https://github.com/alexweissman/wdvss">WDVSS request schema</a>.  The <strong>request schema</strong> allows us to apply some common validation rules as defined in the WDVSS standard. In practice, you will often be able to perform simple, syntactic validation (numeric ranges, string lengths, etc) with a request schema, but will need to hand-code more complex database-driven validation (checking that a username is not in use, validating a security token, etc).</p>

<p>Let&#39;s create a simple WDVSS request schema, written as a JSON document, for our form:</p>

<p><strong>/schema/forms/group-titles.json</strong></p>

<pre><code>{
    &quot;group_id&quot; : {
        &quot;validators&quot; : {
              &quot;integer&quot; : {
                  &quot;message&quot; : &quot;group_id must be an integer.&quot;
              }
        },
        &quot;sanitizers&quot; : {
            &quot;raw&quot; : &quot;&quot;
        }
    },
    &quot;title&quot; : {
        &quot;validators&quot; : {
            &quot;length&quot; : {
                &quot;min&quot; : 1,
                &quot;max&quot; : 150,
                &quot;message&quot; : &quot;The new title must be between 1 and 150 characters long.&quot;
            }
        },
        &quot;sanitizers&quot; : {
            &quot;raw&quot; : &quot;&quot;
        }
    }
}</code></pre>

<p>Note that the two top-level keys in this JSON document, <code>group_id</code> and <code>title</code>, match the names of the fields in our form.  For each field we can define one or more validation rule, along with some parameters.  We can also define a sanitization protocol.  In most cases, we actually don&#39;t want to sanitize the input before using it, so we set the sanitizer to <code>raw</code>.</p>

<p>The schema also acts as a whitelist.  Fortress will ignore any submitted fields that do not match the name of a field in the request schema.  This is useful, for example, if we intend to pass the entire array of form data on to some other function, and we want to be sure that no (potentially malicious) data has been snuck into the request.</p>

<p>Ok, so now we can actually use our schema along with Fortress in our controller code:</p>

<pre><code>public function updateGroupTitles(){
   // Access-controlled resource
   if (!$this-&gt;_app-&gt;user-&gt;checkAccess(&#39;uri_group_titles&#39;)){
       $this-&gt;_app-&gt;notFound();
   }
   
   // Fetch the POSTed data
   $post = $this-&gt;_app-&gt;request-&gt;post();
   
   // Load the request schema
   $requestSchema = new \Fortress\RequestSchema($this-&gt;_app-&gt;config(&#39;schema.path&#39;) . &quot;/forms/group-titles.json&quot;);
   
   // Get the alert message stream
   $ms = $this-&gt;_app-&gt;alerts; 

   // Set up Fortress to process the request
   $rf = new \Fortress\HTTPRequestFortress($ms, $requestSchema, $post);                    
    
   // Sanitize
   $rf-&gt;sanitize();
    
   // Validate, and halt on validation errors.
   if (!$rf-&gt;validate()) {
       $this-&gt;_app-&gt;halt(400);
   }   
          
   // Get the filtered data
   $data = $rf-&gt;data();
   
   ...
}</code></pre>

<p>Notice that we pass three things to <code>HTTPRequestFortress</code>: the request schema, the <code>POST</code>ed data, and a <a href="%7B%7Bsite.url%7D%7D/components/#messages">message stream</a> where Fortress can place any error messages generated during validation.</p>

<p>We then call <code>sanitize</code>, which whitelists the <code>POST</code>ed data.  <code>validate</code> applies our validation rules as defined in the schema, returning <code>false</code> if any validation rule was failed.  </p>

<p>If we are processing this form submission via AJAX, and we encounter an error during validation, we can simply <code>halt</code> the request and return an HTTP 400 error code.  Otherwise, we would need to redirect the request back to the original page containing the form - but more on this later.</p>

<p>Oh yeah, there&#39;s one more thing!  There&#39;s actually one more field that gets submitted in every form - the <a href="%7B%7Bsite.url%7D%7D/security">CSRF</a> token.  This gets checked by the CSRF middleware, so we don&#39;t need to worry about it here.  Fortress will, by default, automatically filter it out in the filtered data array, since it is not declared in the request schema.</p>

<h3 id="toc_4">Interacting with the Data Model</h3>

<p>Ok, so now we have a validated, clean <code>group_id</code> and <code>title</code>.  The next thing to do is actually interact with the data model, which will let us update the titles for each user in the database.</p>

<p>The data model allows us to interact with the database via <strong>database objects</strong>, which are object-oriented representations of records in the database.  I&#39;ll do a more in-depth tutorial on the data model later; for now, just follow along with what I&#39;m doing here.</p>

<p>The <code>MySqlUserLoader</code> class (aliased as simply <code>UserLoader</code>) is a static class that lets us fetch one or more <code>User</code> objects from the database.  We can use the <code>fetchAll</code> method to fetch an array of <code>User</code>s, and even filter by some criteria.  For example,</p>

<p><code>$users = UserLoader::fetchAll($post[&#39;group_id&#39;], &quot;primary_group_id&quot;);</code></p>

<p>will give us an array of all users whose primary group is <code>$post[&#39;group_id&#39;]</code>.</p>

<p>Then, we can simply cycle through this array of users, and set their titles to the new value:</p>

<pre><code>foreach ($users as $user_id =&gt; $user){
  $user-&gt;title = $post[&#39;title&#39;];
  $user-&gt;store();
}</code></pre>

<p>Behind the scenes, invoking <code>$user-&gt;title</code> takes advantage of PHP&#39;s <a href="http://php.net/manual/en/language.oop5.magic.php">magic methods</a> to let us get and set the various fields for the database object.  Calling the <code>store()</code> method then commits the modified <code>User</code> back to the database.</p>

<p>Ok, so let&#39;s put the entire route method together:</p>

<pre><code>public function updateGroupTitles(){
   // Access-controlled resource
   if (!$this-&gt;_app-&gt;user-&gt;checkAccess(&#39;uri_group_titles&#39;)){
       $this-&gt;_app-&gt;notFound();
   }
   
   // Fetch the POSTed data
   $post = $this-&gt;_app-&gt;request-&gt;post();
   
   // Load the request schema
   $requestSchema = new \Fortress\RequestSchema($this-&gt;_app-&gt;config(&#39;schema.path&#39;) . &quot;/forms/group-titles.json&quot;);
   
   // Get the alert message stream
   $ms = $this-&gt;_app-&gt;alerts; 

   // Set up Fortress to process the request
   $rf = new \Fortress\HTTPRequestFortress($ms, $requestSchema, $post);                    
    
   // Sanitize
   $rf-&gt;sanitize();
    
   // Validate, and halt on validation errors.
   if (!$rf-&gt;validate()) {
       $this-&gt;_app-&gt;halt(400);
   }   
          
   // Get the filtered data
   $data = $rf-&gt;data();
   
   // Load all users whose primary group matches the requested group
   $users = UserLoader::fetchAll($post[&#39;group_id&#39;], &quot;primary_group_id&quot;);
   
   // Update title for these users
    foreach ($users as $user_id =&gt; $user){
      $user-&gt;title = $post[&#39;title&#39;];
      $user-&gt;store();
    }
    
    // Give us a nice success message
    $ms-&gt;addMessageTranslated(&quot;success&quot;, &quot;Everyone&#39;s title has been updated to {{title}}!&quot;, $post);
    
}</code></pre>

<h2 id="toc_5">Submitting the Form</h2>

<p>Ok, so remember how I mentioned earlier that there are two different ways that we can submit the form?  Well, I did.</p>

<p>One option is to use a traditional form submission (i.e., just creating a submit button and letting HTML handle the rest).  If we do this, most browsers will take the response from the <code>POST</code> request and display it in the browser, just like they do with any other request.  In this case we&#39;d probably want to redirect the browser back to the submitting page, or perhaps a confirmation page, since the response body from the <code>POST</code> request itself will be empty (and we&#39;d just get a blank page).</p>

<p>However, we could choose to use AJAX instead. This is actually how most of the forms that ship with UserFrosting already work. In this case, Javascript will detect when someone submits the form, and will pass the data to the POST route without leaving your current page. In this case, there is no need to redirect to another page (and actually, this wouldn&#39;t work because the response of that redirect would be sent back into the AJAX callback). Then, if necessary, we can use Javascript to reload the page after the request to the POST route is complete.</p>

<p>The other nice thing about using AJAX is that, before the form is actually submitted, we can validate the contents of the fields with a Javascript plugin.  This <strong>does not mean</strong> that we don&#39;t have to validate the data in the <code>POST</code> route as well - it simply makes things a little easier on the client by telling them immediately if their input contains an error.  This way, they don&#39;t have to wait for the round trip to the server and back.</p>

<pre><code>&lt;script&gt;
    $(document).ready(function() { 
      // Process form 
      $(&quot;form[name=&#39;titles&#39;]&quot;).formValidation({
        framework: &#39;bootstrap&#39;,
        // Feedback icons
        icon: {
            valid: &#39;fa fa-check&#39;,
            invalid: &#39;fa fa-times&#39;,
            validating: &#39;fa fa-refresh&#39;
        },
        fields: {{ validators | raw }}
      }).on(&#39;success.form.fv&#39;, function(e) {
        // Prevent double form submission
        e.preventDefault();

        // Get the form instance
        var form = $(e.target);

        // Serialize and post to the backend script in ajax mode
        var serializedData = form.find(&#39;input, textarea, select&#39;).not(&#39;:checkbox&#39;).serialize();
        // Get unchecked checkbox values, set them to 0
        form.find(&#39;input[type=checkbox]&#39;).each(function() {
            if ($(this).is(&#39;:checked&#39;))
                serializedData += &quot;&amp;&quot; + encodeURIComponent(this.name) + &quot;=1&quot;;
            else
                serializedData += &quot;&amp;&quot; + encodeURIComponent(this.name) + &quot;=0&quot;;
        });

        var url = form.attr(&#39;action&#39;);
        return $.ajax({  
          type: &quot;POST&quot;,  
          url: url,  
          data: serializedData       
        }).done(function(data, statusText, jqXHR) {
            // Reload the page
            window.location.reload();
        }).fail(function(jqXHR) {
            if (site[&#39;debug&#39;] == true) {
                document.body.innerHTML = jqXHR.responseText;
            } else {
                console.log(&quot;Error (&quot; + jqXHR.status + &quot;): &quot; + jqXHR.responseText );
            }
        }).always(function(data, statusText, jqXHR){
            // Display messages
            $(&#39;#userfrosting-alerts&#39;).flashAlerts().done(function() {
                // Re-enable submit button
                form.data(&#39;formValidation&#39;).disableSubmitButtons(false);
            });
        });
      });
    });
&lt;/script&gt;</code></pre>

<p>Ok, so what&#39;s going on here?  <code>$(document).ready(...</code> is a jQuery construct that tells us to execute the enclosed code when the HTML document is ready (i.e., the page has completely loaded).</p>

<p><code>$(&quot;form[name=&#39;titles&#39;]&quot;).formValidation(...</code> creates a new instance of the <a href="http://formvalidation.io/">FormValidation</a> plugin, which will perform our client-side validation.  The line <code>fields: {{ validators | raw }}</code> is where Twig will insert the client-side validation rules that it generates from the schema (more on this in a minute).</p>

<p><code>e.preventDefault()</code> overrides the default form submission behavior, letting AJAX take control instead.  We then serialize all the form data into a URI-encoded string, and pass it into a call to <code>$.ajax(...</code>, which actually performs the submission.</p>

<p>The AJAX construct includes three callbacks: <code>.done</code>, <code>.fail</code>, and <code>.always</code>.  <code>.done</code> is called when the <code>POST</code> request is submitted successfully, i.e. when it returns a HTTP <code>200</code> response code.  In this case, we may want to reload the page using <code>window.location.reload()</code> (the necessity of this will depend on your specific application).  </p>

<p><code>.fail</code> is called when the <code>POST</code> request returns an HTTP code other than <code>200</code>, for example <code>400</code>, <code>403</code>, or <code>500</code>.  In this case, we may want to take the client to a debugging page, or simply log the error code in the browser console.</p>

<p><code>.always</code> is called regardless of whether the request was successful or not.  We always want to display any messages from the message stream, using UserFrosting&#39;s <code>flashAlerts()</code> jQuery plugin.  This will take care of displaying both success and error messages.</p>

<p><strong>Add this block of Javascript code immediately before your closing <code>&lt;/body&gt;</code> tag in the page template.</strong></p>

<h3 id="toc_6">Client-side Validation</h3>

<p>Ok, so about that client-side validation.  We already have a Twig placeholder, we just need to generate the appropriate rules as a JSON object.  It turns out that Fortress can do this as well, we simply need to load the <code>RequestSchema</code> in the page route:</p>

<pre><code>public function pageGroupTitles(){
   // Access-controlled resource
   if (!$this-&gt;_app-&gt;user-&gt;checkAccess(&#39;uri_group_titles&#39;)){
       $this-&gt;_app-&gt;notFound();
   }
   
   // Get the validation rules for the form on this page
   $schema = new \Fortress\RequestSchema($this-&gt;_app-&gt;config(&#39;schema.path&#39;) . &quot;/forms/group-titles.json&quot;);
   $validators = new \Fortress\ClientSideValidator($schema, $this-&gt;_app-&gt;translator);           
   
   // Get a list of all groups
   $groups = GroupLoader::fetchAll();
   
   $this-&gt;_app-&gt;render(&#39;group-titles.html&#39;, [
       &#39;page&#39; =&gt; [
           &#39;author&#39; =&gt;         $this-&gt;_app-&gt;site-&gt;author,
           &#39;title&#39; =&gt;          &quot;Update Group Titles&quot;,
           &#39;description&#39; =&gt;    &quot;Update the title for every user in a particular group&quot;,
           &#39;alerts&#39; =&gt;         $this-&gt;_app-&gt;alerts-&gt;getAndClearMessages()
       ],
       &quot;groups&quot; =&gt; $groups,
       &quot;validators&quot; =&gt; $validators-&gt;formValidationRulesJson()   
   ]);   
}</code></pre>

<p>We generate a new <code>ClientSideValidator</code> object from the request schema, and then use the <code>formValidationRulesJson()</code> method to generate the client-side validation rules in the appropriate format for the FormValidation jQuery plugin.  These then get passed into the page template.</p>

<h2 id="toc_7">Wrapping it up</h2>

<p>Alright, so that should do it!  To summarize, we created the following:</p>

<ol>
<li>A <code>GET</code> route and controller method to generate the page that will contain the form.</li>
<li>A <code>POST</code> route and controller method to process the form submission and modify the data model accordingly.</li>
<li>A <a href="https://github.com/alexweissman/wdvss">WDVSS schema</a> to facilitate both server- and client-side validation of user input.</li>
</ol>

<p>If we go back to our page and fill out the form, we should get something like:</p>

<p><img src="%7B%7Bsite.url%7D%7D/img/tutorials/process-form-2.png" alt="UserFrosting - processing a form submission - 2"></p>


</body>

</html>
